# [Theory: Objects](https://hyperskill.org/learn/step/6773)  

## Everything is an object
실생활에서 많은 객체들이 우리 주위에 있습니다. 자동차 운전, TV 시청, 컴퓨터 사용법 배우기, 스마트 폰으로 바나나 값 지불 등의 작업을 할 수 있습니다. 정수 5와 문자열 "high"처럼, Kotlin에서 모든 변수와 값은 객체입니다. 프로그래머는 사람이고 사람은 객체를 다루는 데 익숙하기 때문입니다. 

## Comparison
친구에게서 "Hi"와 "Hi"라는 동일한 메시지를 받았다고 상상해보세요. 두개는 동일한 메세지라고 생각할 것입니다. 그러나 어떤 이유로 Kotlin에서 이 두 메시지를 비교하려는 경우 우선 두 메시지를 문자열 값으로 저장합니다.
```kotlin
val msg1 = "Hi"
val msg2 = "Hi"
```
그리고 나서 비교 연산자인 `==`를 사용하면 됩니다. 예를 들어, `print(msg1 == msg2)`는 true이고 print(msg1 == "Hello")는 false를 출력합니다. 다른 타입의 객체인 경우, 다른관계 연산자를 사용해야 합니다.

## Copying by reference
우리는 객체를 복사 할 수 없을때가 가끔 있습니다. 예를 들어 아이스크림 같은 경우, 공짜로 이것의 복제본을 만들 수 없습니다. 그러나 거울을 보고 반사된 아이스크림을 볼 수는 있습니다. 엄밀히 말하면 원래의 것 같아 보입니다.

Kotlin에서는 이와 유사한 규칙이 적용됩니다. 변수와 값은 객체를 가리키기만 합니다. 즉, 변수를 만들어 객체를 할당하면 다른 변수가 동일한 객체를 가리킬 수도 있습니다. 그리고 이런 문자 메시지를 작성할 경우,
```kotlin
val msg1 = "Hi"
val msg2 = msg1
```
이제 단일 객체 "Hi"를 가리키는 값이 두개가 됩니다.  
![](https://ucarecdn.com/40d6c4df-d493-45fe-ac57-0dd10e321d28/)

즉, <u>`=` 기호는 객체를 복사하지 않고 객체에 대한 참조만 복사합니다.</u> 이것은 중요하게 알아둬야 할 부분인데, 변경 가능한 객체가 있기 때문입니다. 한 곳에서의 변경은 그것을 참조하는 모든 장소에서 변경 될 것입니다. 문자열이나 숫자와 같은 표준타입은 변경 불가능하므로 참조로 복사하는 것이 안전합니다. 나중에 변경할 수 있는 표준타입과 사용자 정의타입 객체에 대한 사본을 만드는 다른 방법에 대해 배우게 니다.

## State and behavior
또한 객체는 속성을 갖고 뭔가 할 수 있습니다. 예를 들어 메시지를 문자열로 다시 예로 들어 봅시다.

무엇보다도 메시지에는 상태가 있습니다. 물론 심볼의 시퀀스가 포함되어 있지만 시퀀스의 크기(길이)도 포함됩니다. 여러분이 객체의 상태에 접근 할 수있게 해주는 것을 Kotlin의 속성이라고합니다. 객체 뒤에 점과 이름을 쓰면 원하는 것을 얻을 수 있습니다! 사실, 문자열에는 .length 속성이 있으므로 msg1.length는 2를 제공합니다.

두번째로, Kotlin에서 일부함수는 특정타입에 바인딩됩니다. 함수는 객체의 동작을 나타내기 때문에 객체의 사용을 보다 논리적으로 만들 수 있습니다. 문법은 유사합니다. 단지 점을 써야합니다. 그리고 우리는 다시 메시지를 반복 할 수 있습니다 : msg1.repeat(3)은 우리에게 "HiHiHi"라는 결과를 보여줍니다.

> 실행활에 있는 모든 객체를 열거할 수 있습니까?? 중요한 사실은, 특정 객체를 사용하는 그 순간에 같은 종류의 모든 객체와 동시에 상호 작용하지 않는다는 것입니다. 예를 들어, 당신이 문 하나를 연다고 전 세계의 모든 문이 열리는 것은 아닙니다. 그래서 당연하지만 모든 문자열의 길이가 2는 아닙니다. 문자열 "Hi"가 아닌 다른 문자열을 3번 반복한다면 "HiHiHi"를 얻지 못합니다.
 
 ## More about functions  
 obj라는 변수가 있을 때 `f(obj)`와 같은 함수와 `obj.f()`와 같은 함수를 호출 할 수 있습니다.

객체를 받는 함수(f(obj))와 객체에 바인드 된 함수(obj.f()) 사이에는 차이가 있습니다. 개념적인 부분이라 설명하기가 어렵지만 다시 아까의 예제를 사용하겠습니다.

1. print는 객체를 받는 입니다. 문자열을 받아서 콘솔로 출력 할 수 있습니다. 콘솔과 문자열 사이에는 많은 관계가 없으므로 출력함수는 점(.)을 통해 문자열에 바인딩되지 않습니다.
2. .repeat는 문자열에 바인딩된 함수입니다. 이것은 문자열의 동작이며 새로운 문자열을 만드는 방법입니다. 따라서 이 함수를 문자열에 바인딩 시키는것이 합리적입니다.

## Conclusion
이러한 공통적인 사실은 Kotlin의 모든 객체에 거의 작용합니다. 그들은 실생활과 관련이 있기 때문에 존재합니다. Kotlin 개발자는 코드를 명확하게 하려고 노력하기 때문에 함수에 다른 구문을 사용합니다.
